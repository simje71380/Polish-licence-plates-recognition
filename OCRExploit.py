from tensorflow import keras
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from tensorflow.keras.preprocessing import image as image_utils
import numpy as np
from sklearn.preprocessing import LabelEncoder
import cv2
import pickle

def show_image(image_path):
    image = mpimg.imread(image_path)
    plt.imshow(image, cmap='gray')

def load_and_scale_image(image_path):
    image = image_utils.load_img(image_path, color_mode="grayscale", target_size=(64,64))
    return image

def predict_old(file_path):
    model = keras.models.load_model('Tensorflow\OCR_model')
    label_decoder = LabelEncoder()
    label_decoder.classes_ = np.load('Tensorflow\OCR_model\label_encoder.npy')
    show_image(file_path)
    image = load_and_scale_image(file_path)
    image = image_utils.img_to_array(image)
    image = image.reshape(1,64,64,1) 
    image = image/255
    prediction = model.predict(image)
    print(prediction.shape)
    # convert prediction to letter or number
    predicted_labels = label_decoder.inverse_transform(np.argmax(prediction, axis=1))
    plt.show()
    return predicted_labels

def decode_output(argmax):
    if(argmax < 10): 
        return str(argmax)
    else:
        return chr(argmax + 96 - 9)

def predict(letters):
    #load the model
    model = keras.models.load_model("Tensorflow\OCR_model_V2")

    fig = plt.figure()
    i = 1
    for letter in letters:
        # Convert to grayscale and resize
        gray = cv2.cvtColor(letter, cv2.COLOR_BGR2GRAY)
        image = cv2.resize(gray, (56, 56), interpolation = cv2.INTER_LINEAR)

        #add padding
        target_size = (64, 64)
        pad_height = max(0, target_size[0] - image.shape[0])
        pad_width = max(0, target_size[1] - image.shape[1])
        top = pad_height // 2
        bottom = pad_height - top
        left = pad_width // 2
        right = pad_width - left
        image_padded = cv2.copyMakeBorder(image, top, bottom, left, right, cv2.BORDER_CONSTANT, value=255)

        # threshold
        _, image = cv2.threshold(image_padded, 75, 255, cv2.THRESH_BINARY)

        plt.subplot(1, 9, i),
        plt.imshow(image, cmap='gray')

        # Adapt to NN input
        image = image_utils.img_to_array(image)
        image = image.reshape(-1,64,64,1) 
        image = image/255
        prediction = model.predict(image)

        # convert prediction to letter or number
        predicted_labels = decode_output(np.argmax(prediction))
        plt.title(str(predicted_labels[0]))
        i += 1

    plt.show()
    return predicted_labels

'''
if __name__ == "__main__":
    

    print(predict_old('OCRDataset/testing_data/L/28331.png'))
    plt.show()

'''